module regfile (
    input clk,  // clock
    input rst,  // reset
    
    input ra[4], // a input
    input rb[4], // b input 
    
    input rc[4], // write address
    input we, // write enable
    input data[16], // data sent out from ALU back to regfile
    
    // outputs for regfile storage
    output out_a[16],
    output out_b[16],
    
    // outputs to be sent to betacpu 
    output column_1[16],
    output column_2[16],
    output column_3[16],
    output column_4[16]
  ) {
  
  // all regfile registers used
  .clk(clk){
    .rst(rst){
      dff col0[16];
      dff col1[16];
      dff col2[16];
      dff col3[16];
      dff blank[16](#INIT(0));
      dff combo[16];
      dff score[16];
      dff counter[16];
      dff total_notes[16];
      dff most_sigbits[16];
      dff selected_col[16];
      dff selected_col_address[16];
      dff add_score[16];
      dff reg_temp[3][16];
    }
  }
  
  always{
    
    // write enable storage of data based on register called by rc
    if (we){
        case(rc){
          4h0: col0.d = data;
          4h1: col1.d = data;
          4h2: col2.d = data;
          4h3: col3.d = data;
          4h4: blank.d = data;
          4h5: combo.d = data;
          4h6: score.d = data;
          4h7: counter.d = data;
          4h8: total_notes.d = data;
          4h9: most_sigbits.d = data;
          4ha: selected_col.d = data;
          4hb: selected_col_address.d = data;
          4hc: add_score.d = data;
          4hd: reg_temp.d[0] = data;
          4he: reg_temp.d[1] = data;
          4hf: reg_temp.d[2] = data;
       }    
    }
    
    // retrieves data based on registers called by ra and rb for the betacpu
    case(ra){
          4h0: out_a = col0.q;
          4h1: out_a = col1.q;
          4h2: out_a = col2.q;
          4h3: out_a = col3.q;
          4h4: out_a = blank.q;
          4h5: out_a = combo.q;
          4h6: out_a = score.q;
          4h7: out_a = counter.q;
          4h8: out_a = total_notes.q;
          4h9: out_a = most_sigbits.q;
          4ha: out_a = selected_col.q;
          4hb: out_a = selected_col_address.q;
          4hc: out_a = add_score.q;
          4hd: out_a = reg_temp.q[0];
          4he: out_a = reg_temp.q[1];
          4hf: out_a = reg_temp.q[2];
          
          default: out_a = 0;
    }
        
    case(rb){
          4h0: out_b = col0.q;
          4h1: out_b = col1.q;
          4h2: out_b = col2.q;
          4h3: out_b = col3.q;
          4h4: out_b = blank.q;
          4h5: out_b = combo.q;
          4h6: out_b = score.q;
          4h7: out_b = counter.q;
          4h8: out_b = total_notes.q;
          4h9: out_b = most_sigbits.q;
          4ha: out_b = selected_col.q;
          4hb: out_b = selected_col_address.q;
          4hc: out_b = add_score.q;
          4hd: out_b = reg_temp.q[0];
          4he: out_b = reg_temp.q[1];
          4hf: out_b = reg_temp.q[2];
          
          default: out_b = 0;
    }
    
    // outputs sent to betacpu 
    column_1 = col0.q;
    column_2 = col1.q;
    column_3 = col2.q;
    column_4 = col3.q;
   
  }
}
